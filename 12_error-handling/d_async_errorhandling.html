<!--
SPDX-License-Identifier: GPL-3.0-or-later
Copyright (C) 2025 Manuel Regamey
This file is part of SluInk. See the LICENSE file or <https://www.gnu.org/licenses/>.
-->

<!DOCTYPE html>
<html lang="fr"  data-theme="">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini-JS  d_async_errorhandling</title>
        <meta name="description" content="Les erreurs dans le code
asynchrone sont plus difficiles à gérer, car elles ne se produisent pas
immédiatement. JavaScript propose plusieurs techniques, comme les
promesses et <code>async/await</code>, pour les intercepter et réagir
correctement." />
  <!-- Boot-script: applique le thème choisi avant de charger la CSS -->
  <script>
    (function () {
      var key = 'SluInk-theme';
      try {
        var saved = localStorage.getItem(key);
        var t = (saved === 'light' || saved === 'dark')
          ? saved
          : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        document.documentElement.dataset.theme = t;
        document.documentElement.style.colorScheme = t; // scrollbars/UI natifs
      } catch (e) { }
    })();
  </script>

    <link rel="stylesheet" href="../assets/style.css" />
  
    <style type="text/css">
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
    
    <script src="../assets/script.js" defer></script>
  </head>

<body>

  <header class="site">
    <div class="brand">
      <a href="../index.html">
        Mini-JS
      </a>
    </div>

    <nav class="topnav">
            <a class="nav-prev" href="c_try...catch...finally.html">c_try...catch...finally</a>
            <a class="nav-home" href="../index.html">Accueil</a>
            <a class="nav-next" href="e_exercices.html">e_Exercices</a>
          </nav>

    <div class="theme-buttons" role="group" aria-label="Thème" style="display:flex; gap:.5rem;">
      <button class="button icon-btn" data-theme-set="light" aria-label="Clair" title="Clair">
        <img src="../assets/sun-regular-full.svg" alt="sun" width="20" height="20" />
      </button>
      <button class="button icon-btn" data-theme-set="dark" aria-label="Sombre" title="Sombre">
        <img src="../assets/moon-regular-full.svg" alt="moon" width="20" height="20" />
      </button>
      <button class="button icon-btn" data-theme-set="academic" aria-label="Academic" title="Academic">
        <img src="../assets/file-regular-full.svg" alt="file" width="20" height="20" />
      </button>
    </div>


  </header>

  <div class="layout">
    <aside class="sidebar">
            <nav aria-label="Sommaire">
        <ul>
        <li><a href="#la-gestion-des-erreurs-asynchrones"
        id="toc-la-gestion-des-erreurs-asynchrones">La gestion des
        erreurs asynchrones</a>
        <ul>
        <li><a href="#les-promesses-et-.catch"
        id="toc-les-promesses-et-.catch">Les promesses et
        <code>.catch()</code></a></li>
        <li><a href="#la-syntaxe-asyncawait-et-try...catch"
        id="toc-la-syntaxe-asyncawait-et-try...catch">La syntaxe
        <code>async/await</code> et <code>try...catch</code></a></li>
        <li><a href="#bonnes-pratiques" id="toc-bonnes-pratiques">Bonnes
        pratiques</a></li>
        <li><a href="#à-retenir" id="toc-à-retenir">À retenir</a></li>
        </ul></li>
        </ul>
      </nav>
          </aside>

    <main class="content" id="content">
      <h1 class="title">Mini-JS d_async_errorhandling</h1>
      
      
      
      <h1 id="la-gestion-des-erreurs-asynchrones">La gestion des erreurs
      asynchrones</h1>
      <p>Dans le cas du code synchrone, une erreur se produit au moment
      même où l’instruction est exécutée. Le bloc
      <code>try...catch</code> suffit alors pour l’intercepter. Mais les
      choses se compliquent avec le code asynchrone : les erreurs
      n’apparaissent pas forcément au moment du déclenchement, mais plus
      tard, quand une opération différée se termine.</p>
      <p>Prenons un exemple courant : une requête vers un serveur. On
      envoie la demande maintenant, mais la réponse n’arrivera que dans
      quelques instants. Si cette réponse contient une erreur, elle se
      produit en dehors du flot d’exécution immédiat. Il faut donc des
      mécanismes spécifiques pour les capturer.</p>
      <h2 id="les-promesses-et-.catch">Les promesses et
      <code>.catch()</code></h2>
      <p>En JavaScript moderne, une grande partie du code asynchrone
      repose sur les promesses. Lorsqu’une promesse échoue, elle se «
      rejette » avec une erreur. Pour la gérer, il suffit d’ajouter un
      <code>.catch()</code> à la chaîne.</p>
      <div class="sourceCode" id="cb1"><pre
      class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch</span>(<span class="st">&quot;https://api.example.com/data&quot;</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(response <span class="kw">=&gt;</span> {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="vs">`Erreur HTTP ! statut : </span><span class="sc">${</span>response<span class="op">.</span><span class="at">status</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(data <span class="kw">=&gt;</span> {</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Données reçues :&quot;</span><span class="op">,</span> data)<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;Erreur lors de la récupération :&quot;</span><span class="op">,</span> error)<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
      <p>Dans cet exemple, si le serveur renvoie un code d’erreur, le
      rejet de la promesse sera capturé par le <code>.catch()</code>,
      qui affiche alors un message approprié.</p>
      <h2 id="la-syntaxe-asyncawait-et-try...catch">La syntaxe
      <code>async/await</code> et <code>try...catch</code></h2>
      <p>La syntaxe <code>async/await</code> rend le code asynchrone
      plus lisible, en lui donnant l’apparence d’un code synchrone. Elle
      permet également d’utiliser <code>try...catch</code> pour
      intercepter les erreurs.</p>
      <div class="sourceCode" id="cb2"><pre
      class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">fetchData</span>(url) {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(url)<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">!</span>response<span class="op">.</span><span class="at">ok</span>) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="vs">`Erreur HTTP ! statut : </span><span class="sc">${</span>response<span class="op">.</span><span class="at">status</span><span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> data<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (error) {</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;Erreur lors de la récupération :&quot;</span><span class="op">,</span> error)<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
      <p>Ici, si une erreur survient pendant l’appel ou la conversion en
      JSON, elle est interceptée par le bloc <code>catch</code>. Le flux
      d’exécution reste donc maîtrisé.</p>
      <h2 id="bonnes-pratiques">Bonnes pratiques</h2>
      <p>Gérer les erreurs asynchrones demande quelques habitudes
      supplémentaires :</p>
      <ul>
      <li><strong>Toujours prévoir un traitement d’erreur</strong> : ne
      laissez pas une promesse sans <code>.catch()</code>.</li>
      <li><strong>Offrir un comportement de secours</strong> : quand une
      opération échoue, on peut renvoyer des données par défaut ou un
      message compréhensible pour l’utilisateur.</li>
      <li><strong>Consigner les erreurs</strong> : en plus de les
      afficher, il est souvent utile de les enregistrer dans un service
      de suivi pour comprendre ce qui se passe en production.</li>
      <li><strong>Éviter les échecs silencieux</strong> : ne jamais
      ignorer une erreur sans la gérer ou au minimum l’afficher.</li>
      <li><strong>Centraliser la gestion</strong> : dans les
      applications complexes, il peut être judicieux de regrouper le
      traitement des erreurs pour garder une cohérence.</li>
      </ul>
      <hr />
      <h2 id="à-retenir">À retenir</h2>
      <p>Les erreurs asynchrones ne peuvent pas être interceptées par un
      simple <code>try...catch</code> appliqué au code synchrone. Elles
      apparaissent plus tard, une fois l’opération terminée. Pour les
      gérer, JavaScript propose deux approches principales :</p>
      <ul>
      <li>utiliser le <code>.catch()</code> des promesses,</li>
      <li>ou bien combiner <code>async/await</code> avec
      <code>try...catch</code>.</li>
      </ul>
      <p>Une gestion attentive et cohérente des erreurs asynchrones est
      essentielle pour construire des applications robustes et
      fiables.</p>
      <hr />
      <p>⬅️ <a href="./c_try...catch...finally.html">Chapitre précédent
      : try…catch…finally</a></p>
      <p>➡️ <a href="./e_exercices.html">Chapitre suivant :
      Exercices</a></p>
    </main>
  </div>

  <footer class="site">
    © Manuel Regamey 2025 Mini-JS Généré avec [SluInk]
  </footer>

  </body>

</html>
